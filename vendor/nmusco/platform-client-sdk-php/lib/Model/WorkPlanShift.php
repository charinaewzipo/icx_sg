<?php
/**
 * WorkPlanShift
 *
 * PHP version 5
 *
 * @category Class
 * @package  PureCloudPlatform\Client\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PureCloud Platform API
 *
 * With the PureCloud Platform API, you can control all aspects of your PureCloud environment. With the APIs you can access the system configuration, manage conversations and more.
 *
 * OpenAPI spec version: v2
 * Contact: DeveloperEvangelists@genesys.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.9
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace PureCloudPlatform\Client\V2\Model;

use \ArrayAccess;
use \PureCloudPlatform\Client\V2\ObjectSerializer;

/**
 * WorkPlanShift Class Doc Comment
 *
 * @category Class
 * @description Shift in a work plan
 * @package  PureCloudPlatform\Client\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class WorkPlanShift implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'WorkPlanShift';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'name' => 'string',
        'days' => '\PureCloudPlatform\Client\V2\Model\SetWrapperDayOfWeek',
        'flexibleStartTime' => 'bool',
        'exactStartTimeMinutesFromMidnight' => 'int',
        'earliestStartTimeMinutesFromMidnight' => 'int',
        'latestStartTimeMinutesFromMidnight' => 'int',
        'constrainStopTime' => 'bool',
        'constrainLatestStopTime' => 'bool',
        'latestStopTimeMinutesFromMidnight' => 'int',
        'constrainEarliestStopTime' => 'bool',
        'earliestStopTimeMinutesFromMidnight' => 'int',
        'startIncrementMinutes' => 'int',
        'flexiblePaidTime' => 'bool',
        'exactPaidTimeMinutes' => 'int',
        'minimumPaidTimeMinutes' => 'int',
        'maximumPaidTimeMinutes' => 'int',
        'constrainContiguousWorkTime' => 'bool',
        'minimumContiguousWorkTimeMinutes' => 'int',
        'maximumContiguousWorkTimeMinutes' => 'int',
        'synchronizeAgentsSchedules' => 'bool',
        'synchronizationType' => 'string',
        'constrainDayOff' => 'bool',
        'dayOffRule' => 'string',
        'activities' => '\PureCloudPlatform\Client\V2\Model\WorkPlanActivity[]',
        'id' => 'string',
        'delete' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'name' => null,
        'days' => null,
        'flexibleStartTime' => null,
        'exactStartTimeMinutesFromMidnight' => 'int32',
        'earliestStartTimeMinutesFromMidnight' => 'int32',
        'latestStartTimeMinutesFromMidnight' => 'int32',
        'constrainStopTime' => null,
        'constrainLatestStopTime' => null,
        'latestStopTimeMinutesFromMidnight' => 'int32',
        'constrainEarliestStopTime' => null,
        'earliestStopTimeMinutesFromMidnight' => 'int32',
        'startIncrementMinutes' => 'int32',
        'flexiblePaidTime' => null,
        'exactPaidTimeMinutes' => 'int32',
        'minimumPaidTimeMinutes' => 'int32',
        'maximumPaidTimeMinutes' => 'int32',
        'constrainContiguousWorkTime' => null,
        'minimumContiguousWorkTimeMinutes' => 'int32',
        'maximumContiguousWorkTimeMinutes' => 'int32',
        'synchronizeAgentsSchedules' => null,
        'synchronizationType' => null,
        'constrainDayOff' => null,
        'dayOffRule' => null,
        'activities' => null,
        'id' => null,
        'delete' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'days' => 'days',
        'flexibleStartTime' => 'flexibleStartTime',
        'exactStartTimeMinutesFromMidnight' => 'exactStartTimeMinutesFromMidnight',
        'earliestStartTimeMinutesFromMidnight' => 'earliestStartTimeMinutesFromMidnight',
        'latestStartTimeMinutesFromMidnight' => 'latestStartTimeMinutesFromMidnight',
        'constrainStopTime' => 'constrainStopTime',
        'constrainLatestStopTime' => 'constrainLatestStopTime',
        'latestStopTimeMinutesFromMidnight' => 'latestStopTimeMinutesFromMidnight',
        'constrainEarliestStopTime' => 'constrainEarliestStopTime',
        'earliestStopTimeMinutesFromMidnight' => 'earliestStopTimeMinutesFromMidnight',
        'startIncrementMinutes' => 'startIncrementMinutes',
        'flexiblePaidTime' => 'flexiblePaidTime',
        'exactPaidTimeMinutes' => 'exactPaidTimeMinutes',
        'minimumPaidTimeMinutes' => 'minimumPaidTimeMinutes',
        'maximumPaidTimeMinutes' => 'maximumPaidTimeMinutes',
        'constrainContiguousWorkTime' => 'constrainContiguousWorkTime',
        'minimumContiguousWorkTimeMinutes' => 'minimumContiguousWorkTimeMinutes',
        'maximumContiguousWorkTimeMinutes' => 'maximumContiguousWorkTimeMinutes',
        'synchronizeAgentsSchedules' => 'synchronizeAgentsSchedules',
        'synchronizationType' => 'synchronizationType',
        'constrainDayOff' => 'constrainDayOff',
        'dayOffRule' => 'dayOffRule',
        'activities' => 'activities',
        'id' => 'id',
        'delete' => 'delete'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'days' => 'setDays',
        'flexibleStartTime' => 'setFlexibleStartTime',
        'exactStartTimeMinutesFromMidnight' => 'setExactStartTimeMinutesFromMidnight',
        'earliestStartTimeMinutesFromMidnight' => 'setEarliestStartTimeMinutesFromMidnight',
        'latestStartTimeMinutesFromMidnight' => 'setLatestStartTimeMinutesFromMidnight',
        'constrainStopTime' => 'setConstrainStopTime',
        'constrainLatestStopTime' => 'setConstrainLatestStopTime',
        'latestStopTimeMinutesFromMidnight' => 'setLatestStopTimeMinutesFromMidnight',
        'constrainEarliestStopTime' => 'setConstrainEarliestStopTime',
        'earliestStopTimeMinutesFromMidnight' => 'setEarliestStopTimeMinutesFromMidnight',
        'startIncrementMinutes' => 'setStartIncrementMinutes',
        'flexiblePaidTime' => 'setFlexiblePaidTime',
        'exactPaidTimeMinutes' => 'setExactPaidTimeMinutes',
        'minimumPaidTimeMinutes' => 'setMinimumPaidTimeMinutes',
        'maximumPaidTimeMinutes' => 'setMaximumPaidTimeMinutes',
        'constrainContiguousWorkTime' => 'setConstrainContiguousWorkTime',
        'minimumContiguousWorkTimeMinutes' => 'setMinimumContiguousWorkTimeMinutes',
        'maximumContiguousWorkTimeMinutes' => 'setMaximumContiguousWorkTimeMinutes',
        'synchronizeAgentsSchedules' => 'setSynchronizeAgentsSchedules',
        'synchronizationType' => 'setSynchronizationType',
        'constrainDayOff' => 'setConstrainDayOff',
        'dayOffRule' => 'setDayOffRule',
        'activities' => 'setActivities',
        'id' => 'setId',
        'delete' => 'setDelete'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'days' => 'getDays',
        'flexibleStartTime' => 'getFlexibleStartTime',
        'exactStartTimeMinutesFromMidnight' => 'getExactStartTimeMinutesFromMidnight',
        'earliestStartTimeMinutesFromMidnight' => 'getEarliestStartTimeMinutesFromMidnight',
        'latestStartTimeMinutesFromMidnight' => 'getLatestStartTimeMinutesFromMidnight',
        'constrainStopTime' => 'getConstrainStopTime',
        'constrainLatestStopTime' => 'getConstrainLatestStopTime',
        'latestStopTimeMinutesFromMidnight' => 'getLatestStopTimeMinutesFromMidnight',
        'constrainEarliestStopTime' => 'getConstrainEarliestStopTime',
        'earliestStopTimeMinutesFromMidnight' => 'getEarliestStopTimeMinutesFromMidnight',
        'startIncrementMinutes' => 'getStartIncrementMinutes',
        'flexiblePaidTime' => 'getFlexiblePaidTime',
        'exactPaidTimeMinutes' => 'getExactPaidTimeMinutes',
        'minimumPaidTimeMinutes' => 'getMinimumPaidTimeMinutes',
        'maximumPaidTimeMinutes' => 'getMaximumPaidTimeMinutes',
        'constrainContiguousWorkTime' => 'getConstrainContiguousWorkTime',
        'minimumContiguousWorkTimeMinutes' => 'getMinimumContiguousWorkTimeMinutes',
        'maximumContiguousWorkTimeMinutes' => 'getMaximumContiguousWorkTimeMinutes',
        'synchronizeAgentsSchedules' => 'getSynchronizeAgentsSchedules',
        'synchronizationType' => 'getSynchronizationType',
        'constrainDayOff' => 'getConstrainDayOff',
        'dayOffRule' => 'getDayOffRule',
        'activities' => 'getActivities',
        'id' => 'getId',
        'delete' => 'getDelete'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const SYNCHRONIZATION_TYPE_SHIFT_START = 'ShiftStart';
    const SYNCHRONIZATION_TYPE_SHIFT_START_AND_PAID_DURATION = 'ShiftStartAndPaidDuration';
    const DAY_OFF_RULE_NEXT_DAY_OFF = 'NextDayOff';
    const DAY_OFF_RULE_PREVIOUS_DAY_OFF = 'PreviousDayOff';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSynchronizationTypeAllowableValues()
    {
        return [
            self::SYNCHRONIZATION_TYPE_SHIFT_START,
            self::SYNCHRONIZATION_TYPE_SHIFT_START_AND_PAID_DURATION,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDayOffRuleAllowableValues()
    {
        return [
            self::DAY_OFF_RULE_NEXT_DAY_OFF,
            self::DAY_OFF_RULE_PREVIOUS_DAY_OFF,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['days'] = isset($data['days']) ? $data['days'] : null;
        $this->container['flexibleStartTime'] = isset($data['flexibleStartTime']) ? $data['flexibleStartTime'] : null;
        $this->container['exactStartTimeMinutesFromMidnight'] = isset($data['exactStartTimeMinutesFromMidnight']) ? $data['exactStartTimeMinutesFromMidnight'] : null;
        $this->container['earliestStartTimeMinutesFromMidnight'] = isset($data['earliestStartTimeMinutesFromMidnight']) ? $data['earliestStartTimeMinutesFromMidnight'] : null;
        $this->container['latestStartTimeMinutesFromMidnight'] = isset($data['latestStartTimeMinutesFromMidnight']) ? $data['latestStartTimeMinutesFromMidnight'] : null;
        $this->container['constrainStopTime'] = isset($data['constrainStopTime']) ? $data['constrainStopTime'] : null;
        $this->container['constrainLatestStopTime'] = isset($data['constrainLatestStopTime']) ? $data['constrainLatestStopTime'] : null;
        $this->container['latestStopTimeMinutesFromMidnight'] = isset($data['latestStopTimeMinutesFromMidnight']) ? $data['latestStopTimeMinutesFromMidnight'] : null;
        $this->container['constrainEarliestStopTime'] = isset($data['constrainEarliestStopTime']) ? $data['constrainEarliestStopTime'] : null;
        $this->container['earliestStopTimeMinutesFromMidnight'] = isset($data['earliestStopTimeMinutesFromMidnight']) ? $data['earliestStopTimeMinutesFromMidnight'] : null;
        $this->container['startIncrementMinutes'] = isset($data['startIncrementMinutes']) ? $data['startIncrementMinutes'] : null;
        $this->container['flexiblePaidTime'] = isset($data['flexiblePaidTime']) ? $data['flexiblePaidTime'] : null;
        $this->container['exactPaidTimeMinutes'] = isset($data['exactPaidTimeMinutes']) ? $data['exactPaidTimeMinutes'] : null;
        $this->container['minimumPaidTimeMinutes'] = isset($data['minimumPaidTimeMinutes']) ? $data['minimumPaidTimeMinutes'] : null;
        $this->container['maximumPaidTimeMinutes'] = isset($data['maximumPaidTimeMinutes']) ? $data['maximumPaidTimeMinutes'] : null;
        $this->container['constrainContiguousWorkTime'] = isset($data['constrainContiguousWorkTime']) ? $data['constrainContiguousWorkTime'] : null;
        $this->container['minimumContiguousWorkTimeMinutes'] = isset($data['minimumContiguousWorkTimeMinutes']) ? $data['minimumContiguousWorkTimeMinutes'] : null;
        $this->container['maximumContiguousWorkTimeMinutes'] = isset($data['maximumContiguousWorkTimeMinutes']) ? $data['maximumContiguousWorkTimeMinutes'] : null;
        $this->container['synchronizeAgentsSchedules'] = isset($data['synchronizeAgentsSchedules']) ? $data['synchronizeAgentsSchedules'] : null;
        $this->container['synchronizationType'] = isset($data['synchronizationType']) ? $data['synchronizationType'] : null;
        $this->container['constrainDayOff'] = isset($data['constrainDayOff']) ? $data['constrainDayOff'] : null;
        $this->container['dayOffRule'] = isset($data['dayOffRule']) ? $data['dayOffRule'] : null;
        $this->container['activities'] = isset($data['activities']) ? $data['activities'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['delete'] = isset($data['delete']) ? $data['delete'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        $allowedValues = $this->getSynchronizationTypeAllowableValues();
        if (!is_null($this->container['synchronizationType']) && !in_array($this->container['synchronizationType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'synchronizationType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDayOffRuleAllowableValues();
        if (!is_null($this->container['dayOffRule']) && !in_array($this->container['dayOffRule'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'dayOffRule', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Name of the shift
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets days
     *
     * @return \PureCloudPlatform\Client\V2\Model\SetWrapperDayOfWeek
     */
    public function getDays()
    {
        return $this->container['days'];
    }

    /**
     * Sets days
     *
     * @param \PureCloudPlatform\Client\V2\Model\SetWrapperDayOfWeek $days Days of the week applicable for this shift
     *
     * @return $this
     */
    public function setDays($days)
    {
        $this->container['days'] = $days;

        return $this;
    }

    /**
     * Gets flexibleStartTime
     *
     * @return bool
     */
    public function getFlexibleStartTime()
    {
        return $this->container['flexibleStartTime'];
    }

    /**
     * Sets flexibleStartTime
     *
     * @param bool $flexibleStartTime Whether the start time of the shift is flexible
     *
     * @return $this
     */
    public function setFlexibleStartTime($flexibleStartTime)
    {
        $this->container['flexibleStartTime'] = $flexibleStartTime;

        return $this;
    }

    /**
     * Gets exactStartTimeMinutesFromMidnight
     *
     * @return int
     */
    public function getExactStartTimeMinutesFromMidnight()
    {
        return $this->container['exactStartTimeMinutesFromMidnight'];
    }

    /**
     * Sets exactStartTimeMinutesFromMidnight
     *
     * @param int $exactStartTimeMinutesFromMidnight Exact start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == false
     *
     * @return $this
     */
    public function setExactStartTimeMinutesFromMidnight($exactStartTimeMinutesFromMidnight)
    {
        $this->container['exactStartTimeMinutesFromMidnight'] = $exactStartTimeMinutesFromMidnight;

        return $this;
    }

    /**
     * Gets earliestStartTimeMinutesFromMidnight
     *
     * @return int
     */
    public function getEarliestStartTimeMinutesFromMidnight()
    {
        return $this->container['earliestStartTimeMinutesFromMidnight'];
    }

    /**
     * Sets earliestStartTimeMinutesFromMidnight
     *
     * @param int $earliestStartTimeMinutesFromMidnight Earliest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true
     *
     * @return $this
     */
    public function setEarliestStartTimeMinutesFromMidnight($earliestStartTimeMinutesFromMidnight)
    {
        $this->container['earliestStartTimeMinutesFromMidnight'] = $earliestStartTimeMinutesFromMidnight;

        return $this;
    }

    /**
     * Gets latestStartTimeMinutesFromMidnight
     *
     * @return int
     */
    public function getLatestStartTimeMinutesFromMidnight()
    {
        return $this->container['latestStartTimeMinutesFromMidnight'];
    }

    /**
     * Sets latestStartTimeMinutesFromMidnight
     *
     * @param int $latestStartTimeMinutesFromMidnight Latest start time of the shift defined as offset minutes from midnight. Used if flexibleStartTime == true
     *
     * @return $this
     */
    public function setLatestStartTimeMinutesFromMidnight($latestStartTimeMinutesFromMidnight)
    {
        $this->container['latestStartTimeMinutesFromMidnight'] = $latestStartTimeMinutesFromMidnight;

        return $this;
    }

    /**
     * Gets constrainStopTime
     *
     * @return bool
     */
    public function getConstrainStopTime()
    {
        return $this->container['constrainStopTime'];
    }

    /**
     * Sets constrainStopTime
     *
     * @param bool $constrainStopTime Whether the latest stop time constraint for the shift is enabled
     *
     * @return $this
     */
    public function setConstrainStopTime($constrainStopTime)
    {
        $this->container['constrainStopTime'] = $constrainStopTime;

        return $this;
    }

    /**
     * Gets constrainLatestStopTime
     *
     * @return bool
     */
    public function getConstrainLatestStopTime()
    {
        return $this->container['constrainLatestStopTime'];
    }

    /**
     * Sets constrainLatestStopTime
     *
     * @param bool $constrainLatestStopTime Whether the latest stop time constraint for the shift is enabled
     *
     * @return $this
     */
    public function setConstrainLatestStopTime($constrainLatestStopTime)
    {
        $this->container['constrainLatestStopTime'] = $constrainLatestStopTime;

        return $this;
    }

    /**
     * Gets latestStopTimeMinutesFromMidnight
     *
     * @return int
     */
    public function getLatestStopTimeMinutesFromMidnight()
    {
        return $this->container['latestStopTimeMinutesFromMidnight'];
    }

    /**
     * Sets latestStopTimeMinutesFromMidnight
     *
     * @param int $latestStopTimeMinutesFromMidnight Latest stop time of the shift defined as offset minutes from midnight. Used if constrainStopTime == true
     *
     * @return $this
     */
    public function setLatestStopTimeMinutesFromMidnight($latestStopTimeMinutesFromMidnight)
    {
        $this->container['latestStopTimeMinutesFromMidnight'] = $latestStopTimeMinutesFromMidnight;

        return $this;
    }

    /**
     * Gets constrainEarliestStopTime
     *
     * @return bool
     */
    public function getConstrainEarliestStopTime()
    {
        return $this->container['constrainEarliestStopTime'];
    }

    /**
     * Sets constrainEarliestStopTime
     *
     * @param bool $constrainEarliestStopTime Whether the earliest stop time constraint for the shift is enabled
     *
     * @return $this
     */
    public function setConstrainEarliestStopTime($constrainEarliestStopTime)
    {
        $this->container['constrainEarliestStopTime'] = $constrainEarliestStopTime;

        return $this;
    }

    /**
     * Gets earliestStopTimeMinutesFromMidnight
     *
     * @return int
     */
    public function getEarliestStopTimeMinutesFromMidnight()
    {
        return $this->container['earliestStopTimeMinutesFromMidnight'];
    }

    /**
     * Sets earliestStopTimeMinutesFromMidnight
     *
     * @param int $earliestStopTimeMinutesFromMidnight This is the earliest time a shift can end
     *
     * @return $this
     */
    public function setEarliestStopTimeMinutesFromMidnight($earliestStopTimeMinutesFromMidnight)
    {
        $this->container['earliestStopTimeMinutesFromMidnight'] = $earliestStopTimeMinutesFromMidnight;

        return $this;
    }

    /**
     * Gets startIncrementMinutes
     *
     * @return int
     */
    public function getStartIncrementMinutes()
    {
        return $this->container['startIncrementMinutes'];
    }

    /**
     * Sets startIncrementMinutes
     *
     * @param int $startIncrementMinutes Increment in offset minutes that would contribute to different possible start times for the shift. Used if flexibleStartTime == true
     *
     * @return $this
     */
    public function setStartIncrementMinutes($startIncrementMinutes)
    {
        $this->container['startIncrementMinutes'] = $startIncrementMinutes;

        return $this;
    }

    /**
     * Gets flexiblePaidTime
     *
     * @return bool
     */
    public function getFlexiblePaidTime()
    {
        return $this->container['flexiblePaidTime'];
    }

    /**
     * Sets flexiblePaidTime
     *
     * @param bool $flexiblePaidTime Whether the paid time setting for the shift is flexible
     *
     * @return $this
     */
    public function setFlexiblePaidTime($flexiblePaidTime)
    {
        $this->container['flexiblePaidTime'] = $flexiblePaidTime;

        return $this;
    }

    /**
     * Gets exactPaidTimeMinutes
     *
     * @return int
     */
    public function getExactPaidTimeMinutes()
    {
        return $this->container['exactPaidTimeMinutes'];
    }

    /**
     * Sets exactPaidTimeMinutes
     *
     * @param int $exactPaidTimeMinutes Exact paid time in minutes configured for the shift. Used if flexiblePaidTime == false
     *
     * @return $this
     */
    public function setExactPaidTimeMinutes($exactPaidTimeMinutes)
    {
        $this->container['exactPaidTimeMinutes'] = $exactPaidTimeMinutes;

        return $this;
    }

    /**
     * Gets minimumPaidTimeMinutes
     *
     * @return int
     */
    public function getMinimumPaidTimeMinutes()
    {
        return $this->container['minimumPaidTimeMinutes'];
    }

    /**
     * Sets minimumPaidTimeMinutes
     *
     * @param int $minimumPaidTimeMinutes Minimum paid time in minutes configured for the shift. Used if flexiblePaidTime == true
     *
     * @return $this
     */
    public function setMinimumPaidTimeMinutes($minimumPaidTimeMinutes)
    {
        $this->container['minimumPaidTimeMinutes'] = $minimumPaidTimeMinutes;

        return $this;
    }

    /**
     * Gets maximumPaidTimeMinutes
     *
     * @return int
     */
    public function getMaximumPaidTimeMinutes()
    {
        return $this->container['maximumPaidTimeMinutes'];
    }

    /**
     * Sets maximumPaidTimeMinutes
     *
     * @param int $maximumPaidTimeMinutes Maximum paid time in minutes configured for the shift. Used if flexiblePaidTime == true
     *
     * @return $this
     */
    public function setMaximumPaidTimeMinutes($maximumPaidTimeMinutes)
    {
        $this->container['maximumPaidTimeMinutes'] = $maximumPaidTimeMinutes;

        return $this;
    }

    /**
     * Gets constrainContiguousWorkTime
     *
     * @return bool
     */
    public function getConstrainContiguousWorkTime()
    {
        return $this->container['constrainContiguousWorkTime'];
    }

    /**
     * Sets constrainContiguousWorkTime
     *
     * @param bool $constrainContiguousWorkTime Whether the contiguous time constraint for the shift is enabled
     *
     * @return $this
     */
    public function setConstrainContiguousWorkTime($constrainContiguousWorkTime)
    {
        $this->container['constrainContiguousWorkTime'] = $constrainContiguousWorkTime;

        return $this;
    }

    /**
     * Gets minimumContiguousWorkTimeMinutes
     *
     * @return int
     */
    public function getMinimumContiguousWorkTimeMinutes()
    {
        return $this->container['minimumContiguousWorkTimeMinutes'];
    }

    /**
     * Sets minimumContiguousWorkTimeMinutes
     *
     * @param int $minimumContiguousWorkTimeMinutes Minimum contiguous time in minutes configured for the shift. Used if constrainContiguousWorkTime == true
     *
     * @return $this
     */
    public function setMinimumContiguousWorkTimeMinutes($minimumContiguousWorkTimeMinutes)
    {
        $this->container['minimumContiguousWorkTimeMinutes'] = $minimumContiguousWorkTimeMinutes;

        return $this;
    }

    /**
     * Gets maximumContiguousWorkTimeMinutes
     *
     * @return int
     */
    public function getMaximumContiguousWorkTimeMinutes()
    {
        return $this->container['maximumContiguousWorkTimeMinutes'];
    }

    /**
     * Sets maximumContiguousWorkTimeMinutes
     *
     * @param int $maximumContiguousWorkTimeMinutes Maximum contiguous time in minutes configured for the shift. Used if constrainContiguousWorkTime == true
     *
     * @return $this
     */
    public function setMaximumContiguousWorkTimeMinutes($maximumContiguousWorkTimeMinutes)
    {
        $this->container['maximumContiguousWorkTimeMinutes'] = $maximumContiguousWorkTimeMinutes;

        return $this;
    }

    /**
     * Gets synchronizeAgentsSchedules
     *
     * @return bool
     */
    public function getSynchronizeAgentsSchedules()
    {
        return $this->container['synchronizeAgentsSchedules'];
    }

    /**
     * Sets synchronizeAgentsSchedules
     *
     * @param bool $synchronizeAgentsSchedules Whether synchronization for agent is enabled
     *
     * @return $this
     */
    public function setSynchronizeAgentsSchedules($synchronizeAgentsSchedules)
    {
        $this->container['synchronizeAgentsSchedules'] = $synchronizeAgentsSchedules;

        return $this;
    }

    /**
     * Gets synchronizationType
     *
     * @return string
     */
    public function getSynchronizationType()
    {
        return $this->container['synchronizationType'];
    }

    /**
     * Sets synchronizationType
     *
     * @param string $synchronizationType This constraint ensures that an agent starts each workday within a user-defined time threshold. Used if synchronizeAgentsSchedules == true
     *
     * @return $this
     */
    public function setSynchronizationType($synchronizationType)
    {
        $allowedValues = $this->getSynchronizationTypeAllowableValues();
        if (!is_null($synchronizationType) && !in_array($synchronizationType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'synchronizationType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['synchronizationType'] = $synchronizationType;

        return $this;
    }

    /**
     * Gets constrainDayOff
     *
     * @return bool
     */
    public function getConstrainDayOff()
    {
        return $this->container['constrainDayOff'];
    }

    /**
     * Sets constrainDayOff
     *
     * @param bool $constrainDayOff Whether day off rule is enabled
     *
     * @return $this
     */
    public function setConstrainDayOff($constrainDayOff)
    {
        $this->container['constrainDayOff'] = $constrainDayOff;

        return $this;
    }

    /**
     * Gets dayOffRule
     *
     * @return string
     */
    public function getDayOffRule()
    {
        return $this->container['dayOffRule'];
    }

    /**
     * Sets dayOffRule
     *
     * @param string $dayOffRule The day off rule for agents to have next day off or previous day off. used if constrainDayOff = true
     *
     * @return $this
     */
    public function setDayOffRule($dayOffRule)
    {
        $allowedValues = $this->getDayOffRuleAllowableValues();
        if (!is_null($dayOffRule) && !in_array($dayOffRule, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'dayOffRule', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['dayOffRule'] = $dayOffRule;

        return $this;
    }

    /**
     * Gets activities
     *
     * @return \PureCloudPlatform\Client\V2\Model\WorkPlanActivity[]
     */
    public function getActivities()
    {
        return $this->container['activities'];
    }

    /**
     * Sets activities
     *
     * @param \PureCloudPlatform\Client\V2\Model\WorkPlanActivity[] $activities Activities configured for this shift
     *
     * @return $this
     */
    public function setActivities($activities)
    {
        $this->container['activities'] = $activities;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id ID of the shift. This is required only for the case of updating an existing shift
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets delete
     *
     * @return bool
     */
    public function getDelete()
    {
        return $this->container['delete'];
    }

    /**
     * Sets delete
     *
     * @param bool $delete If marked true for updating an existing shift, the shift will be permanently deleted
     *
     * @return $this
     */
    public function setDelete($delete)
    {
        $this->container['delete'] = $delete;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


