<?php
/**
 * Callback
 *
 * PHP version 5
 *
 * @category Class
 * @package  PureCloudPlatform\Client\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PureCloud Platform API
 *
 * With the PureCloud Platform API, you can control all aspects of your PureCloud environment. With the APIs you can access the system configuration, manage conversations and more.
 *
 * OpenAPI spec version: v2
 * Contact: DeveloperEvangelists@genesys.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.9
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace PureCloudPlatform\Client\V2\Model;

use \ArrayAccess;
use \PureCloudPlatform\Client\V2\ObjectSerializer;

/**
 * Callback Class Doc Comment
 *
 * @category Class
 * @package  PureCloudPlatform\Client\V2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Callback implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Callback';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'state' => 'string',
        'id' => 'string',
        'segments' => '\PureCloudPlatform\Client\V2\Model\Segment[]',
        'direction' => 'string',
        'held' => 'bool',
        'disconnectType' => 'string',
        'startHoldTime' => '\DateTime',
        'dialerPreview' => '\PureCloudPlatform\Client\V2\Model\DialerPreview',
        'voicemail' => '\PureCloudPlatform\Client\V2\Model\Voicemail',
        'callbackNumbers' => 'string[]',
        'callbackUserName' => 'string',
        'scriptId' => 'string',
        'skipEnabled' => 'bool',
        'timeoutSeconds' => 'int',
        'startAlertingTime' => '\DateTime',
        'connectedTime' => '\DateTime',
        'disconnectedTime' => '\DateTime',
        'callbackScheduledTime' => '\DateTime',
        'automatedCallbackConfigId' => 'string',
        'provider' => 'string',
        'peerId' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'state' => null,
        'id' => null,
        'segments' => null,
        'direction' => null,
        'held' => null,
        'disconnectType' => null,
        'startHoldTime' => 'date-time',
        'dialerPreview' => null,
        'voicemail' => null,
        'callbackNumbers' => null,
        'callbackUserName' => null,
        'scriptId' => null,
        'skipEnabled' => null,
        'timeoutSeconds' => 'int32',
        'startAlertingTime' => 'date-time',
        'connectedTime' => 'date-time',
        'disconnectedTime' => 'date-time',
        'callbackScheduledTime' => 'date-time',
        'automatedCallbackConfigId' => null,
        'provider' => null,
        'peerId' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'state' => 'state',
        'id' => 'id',
        'segments' => 'segments',
        'direction' => 'direction',
        'held' => 'held',
        'disconnectType' => 'disconnectType',
        'startHoldTime' => 'startHoldTime',
        'dialerPreview' => 'dialerPreview',
        'voicemail' => 'voicemail',
        'callbackNumbers' => 'callbackNumbers',
        'callbackUserName' => 'callbackUserName',
        'scriptId' => 'scriptId',
        'skipEnabled' => 'skipEnabled',
        'timeoutSeconds' => 'timeoutSeconds',
        'startAlertingTime' => 'startAlertingTime',
        'connectedTime' => 'connectedTime',
        'disconnectedTime' => 'disconnectedTime',
        'callbackScheduledTime' => 'callbackScheduledTime',
        'automatedCallbackConfigId' => 'automatedCallbackConfigId',
        'provider' => 'provider',
        'peerId' => 'peerId'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'state' => 'setState',
        'id' => 'setId',
        'segments' => 'setSegments',
        'direction' => 'setDirection',
        'held' => 'setHeld',
        'disconnectType' => 'setDisconnectType',
        'startHoldTime' => 'setStartHoldTime',
        'dialerPreview' => 'setDialerPreview',
        'voicemail' => 'setVoicemail',
        'callbackNumbers' => 'setCallbackNumbers',
        'callbackUserName' => 'setCallbackUserName',
        'scriptId' => 'setScriptId',
        'skipEnabled' => 'setSkipEnabled',
        'timeoutSeconds' => 'setTimeoutSeconds',
        'startAlertingTime' => 'setStartAlertingTime',
        'connectedTime' => 'setConnectedTime',
        'disconnectedTime' => 'setDisconnectedTime',
        'callbackScheduledTime' => 'setCallbackScheduledTime',
        'automatedCallbackConfigId' => 'setAutomatedCallbackConfigId',
        'provider' => 'setProvider',
        'peerId' => 'setPeerId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'state' => 'getState',
        'id' => 'getId',
        'segments' => 'getSegments',
        'direction' => 'getDirection',
        'held' => 'getHeld',
        'disconnectType' => 'getDisconnectType',
        'startHoldTime' => 'getStartHoldTime',
        'dialerPreview' => 'getDialerPreview',
        'voicemail' => 'getVoicemail',
        'callbackNumbers' => 'getCallbackNumbers',
        'callbackUserName' => 'getCallbackUserName',
        'scriptId' => 'getScriptId',
        'skipEnabled' => 'getSkipEnabled',
        'timeoutSeconds' => 'getTimeoutSeconds',
        'startAlertingTime' => 'getStartAlertingTime',
        'connectedTime' => 'getConnectedTime',
        'disconnectedTime' => 'getDisconnectedTime',
        'callbackScheduledTime' => 'getCallbackScheduledTime',
        'automatedCallbackConfigId' => 'getAutomatedCallbackConfigId',
        'provider' => 'getProvider',
        'peerId' => 'getPeerId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATE_ALERTING = 'alerting';
    const STATE_DIALING = 'dialing';
    const STATE_CONTACTING = 'contacting';
    const STATE_OFFERING = 'offering';
    const STATE_CONNECTED = 'connected';
    const STATE_DISCONNECTED = 'disconnected';
    const STATE_TERMINATED = 'terminated';
    const STATE_SCHEDULED = 'scheduled';
    const STATE_NONE = 'none';
    const DIRECTION_INBOUND = 'inbound';
    const DIRECTION_OUTBOUND = 'outbound';
    const DISCONNECT_TYPE_ENDPOINT = 'endpoint';
    const DISCONNECT_TYPE_CLIENT = 'client';
    const DISCONNECT_TYPE_SYSTEM = 'system';
    const DISCONNECT_TYPE_TIMEOUT = 'timeout';
    const DISCONNECT_TYPE_TRANSFER = 'transfer';
    const DISCONNECT_TYPE_TRANSFERCONFERENCE = 'transfer.conference';
    const DISCONNECT_TYPE_TRANSFERCONSULT = 'transfer.consult';
    const DISCONNECT_TYPE_TRANSFERFORWARD = 'transfer.forward';
    const DISCONNECT_TYPE_TRANSFERNOANSWER = 'transfer.noanswer';
    const DISCONNECT_TYPE_TRANSFERNOTAVAILABLE = 'transfer.notavailable';
    const DISCONNECT_TYPE_TRANSPORTFAILURE = 'transport.failure';
    const DISCONNECT_TYPE_ERROR = 'error';
    const DISCONNECT_TYPE_PEER = 'peer';
    const DISCONNECT_TYPE_OTHER = 'other';
    const DISCONNECT_TYPE_SPAM = 'spam';
    const DISCONNECT_TYPE_UNCALLABLE = 'uncallable';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ALERTING,
            self::STATE_DIALING,
            self::STATE_CONTACTING,
            self::STATE_OFFERING,
            self::STATE_CONNECTED,
            self::STATE_DISCONNECTED,
            self::STATE_TERMINATED,
            self::STATE_SCHEDULED,
            self::STATE_NONE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDirectionAllowableValues()
    {
        return [
            self::DIRECTION_INBOUND,
            self::DIRECTION_OUTBOUND,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDisconnectTypeAllowableValues()
    {
        return [
            self::DISCONNECT_TYPE_ENDPOINT,
            self::DISCONNECT_TYPE_CLIENT,
            self::DISCONNECT_TYPE_SYSTEM,
            self::DISCONNECT_TYPE_TIMEOUT,
            self::DISCONNECT_TYPE_TRANSFER,
            self::DISCONNECT_TYPE_TRANSFERCONFERENCE,
            self::DISCONNECT_TYPE_TRANSFERCONSULT,
            self::DISCONNECT_TYPE_TRANSFERFORWARD,
            self::DISCONNECT_TYPE_TRANSFERNOANSWER,
            self::DISCONNECT_TYPE_TRANSFERNOTAVAILABLE,
            self::DISCONNECT_TYPE_TRANSPORTFAILURE,
            self::DISCONNECT_TYPE_ERROR,
            self::DISCONNECT_TYPE_PEER,
            self::DISCONNECT_TYPE_OTHER,
            self::DISCONNECT_TYPE_SPAM,
            self::DISCONNECT_TYPE_UNCALLABLE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['segments'] = isset($data['segments']) ? $data['segments'] : null;
        $this->container['direction'] = isset($data['direction']) ? $data['direction'] : null;
        $this->container['held'] = isset($data['held']) ? $data['held'] : null;
        $this->container['disconnectType'] = isset($data['disconnectType']) ? $data['disconnectType'] : null;
        $this->container['startHoldTime'] = isset($data['startHoldTime']) ? $data['startHoldTime'] : null;
        $this->container['dialerPreview'] = isset($data['dialerPreview']) ? $data['dialerPreview'] : null;
        $this->container['voicemail'] = isset($data['voicemail']) ? $data['voicemail'] : null;
        $this->container['callbackNumbers'] = isset($data['callbackNumbers']) ? $data['callbackNumbers'] : null;
        $this->container['callbackUserName'] = isset($data['callbackUserName']) ? $data['callbackUserName'] : null;
        $this->container['scriptId'] = isset($data['scriptId']) ? $data['scriptId'] : null;
        $this->container['skipEnabled'] = isset($data['skipEnabled']) ? $data['skipEnabled'] : null;
        $this->container['timeoutSeconds'] = isset($data['timeoutSeconds']) ? $data['timeoutSeconds'] : null;
        $this->container['startAlertingTime'] = isset($data['startAlertingTime']) ? $data['startAlertingTime'] : null;
        $this->container['connectedTime'] = isset($data['connectedTime']) ? $data['connectedTime'] : null;
        $this->container['disconnectedTime'] = isset($data['disconnectedTime']) ? $data['disconnectedTime'] : null;
        $this->container['callbackScheduledTime'] = isset($data['callbackScheduledTime']) ? $data['callbackScheduledTime'] : null;
        $this->container['automatedCallbackConfigId'] = isset($data['automatedCallbackConfigId']) ? $data['automatedCallbackConfigId'] : null;
        $this->container['provider'] = isset($data['provider']) ? $data['provider'] : null;
        $this->container['peerId'] = isset($data['peerId']) ? $data['peerId'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDirectionAllowableValues();
        if (!is_null($this->container['direction']) && !in_array($this->container['direction'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'direction', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDisconnectTypeAllowableValues();
        if (!is_null($this->container['disconnectType']) && !in_array($this->container['disconnectType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'disconnectType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state The connection state of this communication.
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($state) && !in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id A globally unique identifier for this communication.
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets segments
     *
     * @return \PureCloudPlatform\Client\V2\Model\Segment[]
     */
    public function getSegments()
    {
        return $this->container['segments'];
    }

    /**
     * Sets segments
     *
     * @param \PureCloudPlatform\Client\V2\Model\Segment[] $segments The time line of the participant's callback, divided into activity segments.
     *
     * @return $this
     */
    public function setSegments($segments)
    {
        $this->container['segments'] = $segments;

        return $this;
    }

    /**
     * Gets direction
     *
     * @return string
     */
    public function getDirection()
    {
        return $this->container['direction'];
    }

    /**
     * Sets direction
     *
     * @param string $direction The direction of the call
     *
     * @return $this
     */
    public function setDirection($direction)
    {
        $allowedValues = $this->getDirectionAllowableValues();
        if (!is_null($direction) && !in_array($direction, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'direction', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['direction'] = $direction;

        return $this;
    }

    /**
     * Gets held
     *
     * @return bool
     */
    public function getHeld()
    {
        return $this->container['held'];
    }

    /**
     * Sets held
     *
     * @param bool $held True if this call is held and the person on this side hears silence.
     *
     * @return $this
     */
    public function setHeld($held)
    {
        $this->container['held'] = $held;

        return $this;
    }

    /**
     * Gets disconnectType
     *
     * @return string
     */
    public function getDisconnectType()
    {
        return $this->container['disconnectType'];
    }

    /**
     * Sets disconnectType
     *
     * @param string $disconnectType System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
     *
     * @return $this
     */
    public function setDisconnectType($disconnectType)
    {
        $allowedValues = $this->getDisconnectTypeAllowableValues();
        if (!is_null($disconnectType) && !in_array($disconnectType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'disconnectType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['disconnectType'] = $disconnectType;

        return $this;
    }

    /**
     * Gets startHoldTime
     *
     * @return \DateTime
     */
    public function getStartHoldTime()
    {
        return $this->container['startHoldTime'];
    }

    /**
     * Sets startHoldTime
     *
     * @param \DateTime $startHoldTime The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
     *
     * @return $this
     */
    public function setStartHoldTime($startHoldTime)
    {
        $this->container['startHoldTime'] = $startHoldTime;

        return $this;
    }

    /**
     * Gets dialerPreview
     *
     * @return \PureCloudPlatform\Client\V2\Model\DialerPreview
     */
    public function getDialerPreview()
    {
        return $this->container['dialerPreview'];
    }

    /**
     * Sets dialerPreview
     *
     * @param \PureCloudPlatform\Client\V2\Model\DialerPreview $dialerPreview The preview data to be used when this callback is a Preview.
     *
     * @return $this
     */
    public function setDialerPreview($dialerPreview)
    {
        $this->container['dialerPreview'] = $dialerPreview;

        return $this;
    }

    /**
     * Gets voicemail
     *
     * @return \PureCloudPlatform\Client\V2\Model\Voicemail
     */
    public function getVoicemail()
    {
        return $this->container['voicemail'];
    }

    /**
     * Sets voicemail
     *
     * @param \PureCloudPlatform\Client\V2\Model\Voicemail $voicemail The voicemail data to be used when this callback is an ACD voicemail.
     *
     * @return $this
     */
    public function setVoicemail($voicemail)
    {
        $this->container['voicemail'] = $voicemail;

        return $this;
    }

    /**
     * Gets callbackNumbers
     *
     * @return string[]
     */
    public function getCallbackNumbers()
    {
        return $this->container['callbackNumbers'];
    }

    /**
     * Sets callbackNumbers
     *
     * @param string[] $callbackNumbers The phone number(s) to use to place the callback.
     *
     * @return $this
     */
    public function setCallbackNumbers($callbackNumbers)
    {
        $this->container['callbackNumbers'] = $callbackNumbers;

        return $this;
    }

    /**
     * Gets callbackUserName
     *
     * @return string
     */
    public function getCallbackUserName()
    {
        return $this->container['callbackUserName'];
    }

    /**
     * Sets callbackUserName
     *
     * @param string $callbackUserName The name of the user requesting a callback.
     *
     * @return $this
     */
    public function setCallbackUserName($callbackUserName)
    {
        $this->container['callbackUserName'] = $callbackUserName;

        return $this;
    }

    /**
     * Gets scriptId
     *
     * @return string
     */
    public function getScriptId()
    {
        return $this->container['scriptId'];
    }

    /**
     * Sets scriptId
     *
     * @param string $scriptId The UUID of the script to use.
     *
     * @return $this
     */
    public function setScriptId($scriptId)
    {
        $this->container['scriptId'] = $scriptId;

        return $this;
    }

    /**
     * Gets skipEnabled
     *
     * @return bool
     */
    public function getSkipEnabled()
    {
        return $this->container['skipEnabled'];
    }

    /**
     * Sets skipEnabled
     *
     * @param bool $skipEnabled True if the ability to skip a callback should be enabled.
     *
     * @return $this
     */
    public function setSkipEnabled($skipEnabled)
    {
        $this->container['skipEnabled'] = $skipEnabled;

        return $this;
    }

    /**
     * Gets timeoutSeconds
     *
     * @return int
     */
    public function getTimeoutSeconds()
    {
        return $this->container['timeoutSeconds'];
    }

    /**
     * Sets timeoutSeconds
     *
     * @param int $timeoutSeconds The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled.
     *
     * @return $this
     */
    public function setTimeoutSeconds($timeoutSeconds)
    {
        $this->container['timeoutSeconds'] = $timeoutSeconds;

        return $this;
    }

    /**
     * Gets startAlertingTime
     *
     * @return \DateTime
     */
    public function getStartAlertingTime()
    {
        return $this->container['startAlertingTime'];
    }

    /**
     * Sets startAlertingTime
     *
     * @param \DateTime $startAlertingTime The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
     *
     * @return $this
     */
    public function setStartAlertingTime($startAlertingTime)
    {
        $this->container['startAlertingTime'] = $startAlertingTime;

        return $this;
    }

    /**
     * Gets connectedTime
     *
     * @return \DateTime
     */
    public function getConnectedTime()
    {
        return $this->container['connectedTime'];
    }

    /**
     * Sets connectedTime
     *
     * @param \DateTime $connectedTime The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
     *
     * @return $this
     */
    public function setConnectedTime($connectedTime)
    {
        $this->container['connectedTime'] = $connectedTime;

        return $this;
    }

    /**
     * Gets disconnectedTime
     *
     * @return \DateTime
     */
    public function getDisconnectedTime()
    {
        return $this->container['disconnectedTime'];
    }

    /**
     * Sets disconnectedTime
     *
     * @param \DateTime $disconnectedTime The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
     *
     * @return $this
     */
    public function setDisconnectedTime($disconnectedTime)
    {
        $this->container['disconnectedTime'] = $disconnectedTime;

        return $this;
    }

    /**
     * Gets callbackScheduledTime
     *
     * @return \DateTime
     */
    public function getCallbackScheduledTime()
    {
        return $this->container['callbackScheduledTime'];
    }

    /**
     * Sets callbackScheduledTime
     *
     * @param \DateTime $callbackScheduledTime The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
     *
     * @return $this
     */
    public function setCallbackScheduledTime($callbackScheduledTime)
    {
        $this->container['callbackScheduledTime'] = $callbackScheduledTime;

        return $this;
    }

    /**
     * Gets automatedCallbackConfigId
     *
     * @return string
     */
    public function getAutomatedCallbackConfigId()
    {
        return $this->container['automatedCallbackConfigId'];
    }

    /**
     * Sets automatedCallbackConfigId
     *
     * @param string $automatedCallbackConfigId The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal.
     *
     * @return $this
     */
    public function setAutomatedCallbackConfigId($automatedCallbackConfigId)
    {
        $this->container['automatedCallbackConfigId'] = $automatedCallbackConfigId;

        return $this;
    }

    /**
     * Gets provider
     *
     * @return string
     */
    public function getProvider()
    {
        return $this->container['provider'];
    }

    /**
     * Sets provider
     *
     * @param string $provider The source provider for the callback.
     *
     * @return $this
     */
    public function setProvider($provider)
    {
        $this->container['provider'] = $provider;

        return $this;
    }

    /**
     * Gets peerId
     *
     * @return string
     */
    public function getPeerId()
    {
        return $this->container['peerId'];
    }

    /**
     * Sets peerId
     *
     * @param string $peerId The id of the peer communication corresponding to a matching leg for this communication.
     *
     * @return $this
     */
    public function setPeerId($peerId)
    {
        $this->container['peerId'] = $peerId;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


